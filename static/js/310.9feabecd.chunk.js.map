{"version":3,"file":"static/js/310.9feabecd.chunk.js","mappings":"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","sources":["components/molecules/Word.tsx","services/mergeRefs.ts","services/sortById.ts","components/molecules/Cloud.tsx","components/atoms/Button.tsx","components/molecules/CheckSentenceControls.tsx","hooks/usePrevious.ts","services/calculateBoundingBoxes.ts","hoc/AnimateWords.tsx","components/organisms/DragDrop.tsx","services/isTouchDevice.ts","webpack://my-app/./src/components/atoms/Button.tsx?f41e","webpack://my-app/./src/components/molecules/CheckSentenceControls.tsx?35c4","webpack://my-app/./src/components/molecules/Cloud.tsx?7830","webpack://my-app/./src/components/molecules/Word.tsx?fff4"],"sourcesContent":["import React, { forwardRef, useCallback, useRef } from 'react'\nimport { styled } from 'linaria/react'\nimport { useDrag, useDrop } from 'react-dnd'\nimport Text from '../atoms/Text'\nimport update from 'immutability-helper'\nimport mergeRefs from '../../services/mergeRefs'\nimport { store } from '../../stores/store'\nimport type { Identifier, XYCoord } from 'dnd-core'\nimport { DragItem, ItemT } from '../../types'\n\ntype StyleProps = {\n    isDragging: boolean\n}\n\nconst WordContainer = styled.div<StyleProps>`\n    background: #fff;\n    border: 1px solid #949494;\n    border-radius: 12px;\n    cursor: grab;\n    margin: 5px;\n    user-select: none;\n\n    opacity: ${(props) => (props.isDragging ? 0.5 : 1)};\n`\n\ninterface WordProps {\n    id: number\n    text: string\n    index: number\n    group?: 'start' | 'target'\n}\n\nconst Word = forwardRef<HTMLDivElement, WordProps>(function Word({ id, text, index, group }, ref) {\n    const localRef = useRef<HTMLDivElement>(null)\n\n    const moveWord = useCallback((dragIndex: number, hoverIndex: number) => {\n        store.setTargetWords(\n            update(store.targetWords, {\n                $splice: [\n                    [dragIndex, 1],\n                    [hoverIndex, 0, store.targetWords[dragIndex] as ItemT],\n                ],\n            })\n        )\n    }, [])\n\n    const [{ handlerId }, drop] = useDrop<DragItem, void, { handlerId: Identifier | null }>({\n        accept: 'word',\n        collect: (monitor) => {\n            return {\n                handlerId: monitor.getHandlerId(),\n            }\n        },\n        hover: (item: DragItem, monitor) => {\n            if (group === 'target' && item.group === 'target') {\n                if (!localRef.current) {\n                    return\n                }\n                const dragIndex = item.index\n                const hoverIndex = index\n\n                if (dragIndex === hoverIndex) {\n                    return\n                }\n\n                const hoverBoundingRect = localRef.current?.getBoundingClientRect()\n                const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2\n                const clientOffset = monitor.getClientOffset()\n                const hoverClientX = (clientOffset as XYCoord).x - hoverBoundingRect.left\n\n                if (dragIndex < hoverIndex && hoverClientX < hoverMiddleX) {\n                    return\n                }\n\n                if (dragIndex > hoverIndex && hoverClientX > hoverMiddleX) {\n                    return\n                }\n\n                moveWord(dragIndex, hoverIndex)\n                item.index = hoverIndex\n            }\n        },\n    })\n\n    const [{ isDragging }, drag] = useDrag({\n        type: 'word',\n        item: () => {\n            return { id, index, group }\n        },\n        collect: (monitor) => ({\n            isDragging: monitor.isDragging(),\n        }),\n    })\n    drag(drop(localRef))\n    return (\n        <WordContainer ref={mergeRefs([localRef, ref])} isDragging={isDragging} data-handler-id={handlerId}>\n            <Text text={text} />\n        </WordContainer>\n    )\n})\n\nexport default Word\n","import React from 'react'\n\nexport default function mergeRefs<T = never>(\n    refs: Array<React.MutableRefObject<T> | React.LegacyRef<T>>\n): React.RefCallback<T> {\n    return (value) => {\n        refs.forEach((ref) => {\n            if (typeof ref === 'function') {\n                ref(value)\n            } else if (ref != null) {\n                ;(ref as React.MutableRefObject<T | null>).current = value\n            }\n        })\n    }\n}\n","import { ItemT } from '../types'\r\n\r\nexport const sortById = (wordA: ItemT, wordB: ItemT): number => {\r\n    if (wordA.id > wordB.id) {\r\n        return 1\r\n    }\r\n    if (wordA.id < wordB.id) {\r\n        return -1\r\n    }\r\n    return 0\r\n}\r\n","import React, { useCallback } from 'react'\nimport { styled } from 'linaria/react'\nimport { useDrop } from 'react-dnd'\nimport update from 'immutability-helper'\nimport { sortById } from '../../services/sortById'\nimport { store } from '../../stores/store'\nimport { DragItem } from '../../types'\n\ninterface CloudProps {\n    group: 'start' | 'target'\n}\n\nconst CloudContainer = styled.div`\n    align-content: flex-start;\n    border-top: 1px solid #030303;\n    display: flex;\n    flex-wrap: wrap;\n    min-height: 100px;\n    padding-top: 6px;\n`\n\nconst Cloud: React.FC<CloudProps> = ({ group, children }) => {\n    const moveWordToTargetGroup = useCallback((dragIndex: number) => {\n        store.setTargetWords(\n            update(store.targetWords, {\n                $push: [store.startWords[dragIndex]],\n            })\n        )\n        store.setStartWords(\n            update(store.startWords, {\n                $splice: [[dragIndex, 1]],\n            })\n        )\n    }, [])\n\n    const moveWordToStartGroup = useCallback((dragIndex: number) => {\n        store.setStartWords(\n            update(store.startWords, {\n                $push: [store.targetWords[dragIndex]],\n            })\n        )\n        store.setTargetWords(\n            update(store.targetWords, {\n                $splice: [[dragIndex, 1]],\n            })\n        )\n    }, [])\n\n    const [, drop] = useDrop<DragItem, void>({\n        accept: 'word',\n        drop: (item) => {\n            const dragIndex = item.index\n            if (group === 'target' && item.group === 'start') {\n                moveWordToTargetGroup(dragIndex)\n            }\n            if (group === 'start' && item.group === 'target') {\n                moveWordToStartGroup(dragIndex)\n                setTimeout(() => store.setStartWords([...store.startWords].sort(sortById)), 500)\n            }\n        },\n    })\n    return <CloudContainer ref={drop}>{children}</CloudContainer>\n}\n\nexport default Cloud\n","import React from 'react'\nimport { styled } from 'linaria/react'\n\ninterface ButtonProps {\n    onClick: () => void\n}\n\nconst PrimaryButton = styled.button`\n    background: #fff;\n    border: 1px solid #fff;\n    border-radius: 30px;\n    box-shadow: 5px 7px 10px rgba(0, 0, 0, 0.1);\n    font-size: medium;\n    font-weight: 600;\n    padding: 20px;\n    width: 100%;\n\n    &:active {\n        box-shadow: -5px -8px 10px rgba(0, 0, 0, 0.1);\n    }\n`\n\nconst Button: React.FC<ButtonProps> = ({ onClick }) => {\n    return <PrimaryButton onClick={onClick}>Check</PrimaryButton>\n}\n\nexport default Button\n","import React, { useState } from 'react'\nimport { styled } from 'linaria/react'\nimport { observer } from 'mobx-react-lite'\nimport Text from '../atoms/Text'\nimport Button from '../atoms/Button'\nimport { store } from '../../stores/store'\n\ntype StyleProps = {\n    showStatus: boolean\n    isCorrect: boolean\n}\n\nconst CheckSentenceControlsContainer = styled.div`\n    height: 120px;\n`\n\nconst ButtonContainer = styled.div<Pick<StyleProps, 'showStatus'>>`\n    padding: 0 6px;\n    margin: ${(props) => (props.showStatus ? '12px' : '-32px')} auto;\n    transition: margin 0.5s ease;\n    width: 90%;\n`\n\nconst VerificationStatusContainer = styled.div<Pick<StyleProps, 'isCorrect'>>`\n    display: flex;\n    font-weight: 600;\n    justify-content: center;\n    height: 30px;\n    margin-top: 12px;\n    color: transparent;\n    p {\n        color: ${(props) => (props.isCorrect ? '#17d217' : '#f31616')};\n    }\n`\n\nconst CheckSentenceControls: React.FC = () => {\n    const [isCorrect, setCorrect] = useState<boolean>(false)\n    const [showStatus, setShowStatus] = useState<boolean>(false)\n\n    const checkSentence = () => {\n        store.setSentenceToCheck()\n        if (store.sentenceToCheck !== store.currentSentence.en) {\n            setCorrect(false)\n        }\n        if (store.sentenceToCheck === store.currentSentence.en) {\n            const utterThis = new SpeechSynthesisUtterance(store.sentenceToCheck)\n            utterThis.lang = 'en-US'\n            setCorrect(true)\n            if (!speechSynthesis.speaking) {\n                speechSynthesis.speak(utterThis)\n            }\n        }\n        setShowStatus(true)\n        setTimeout(() => setShowStatus(false), 3000)\n    }\n\n    return (\n        <CheckSentenceControlsContainer>\n            <VerificationStatusContainer isCorrect={isCorrect}>\n                {isCorrect ? <Text text={'Correct!'} /> : <Text text={'Something is wrong!'} />}\n            </VerificationStatusContainer>\n            <ButtonContainer showStatus={showStatus}>\n                <Button onClick={checkSentence} />\n            </ButtonContainer>\n        </CheckSentenceControlsContainer>\n    )\n}\n\nexport default observer(CheckSentenceControls)\n","import { MutableRefObject, useEffect, useRef } from 'react'\n\nfunction usePrevious<T>(value: T): MutableRefObject<T | undefined>['current'] {\n    const ref = useRef<T>()\n    useEffect(() => {\n        ref.current = value\n    }, [value])\n    return ref.current\n}\n\nexport default usePrevious\n","import React from 'react'\nimport { DOMRectsObject } from '../types'\n\nexport interface ChildrenProps {\n    ref: React.RefObject<HTMLDivElement>\n    key: string\n    children: React.ReactNode\n}\n\nconst calculateBoundingBoxes = (children: ChildrenProps) => {\n    const boundingBoxes: DOMRectsObject = {}\n    React.Children.map(children, (child) => {\n        const domNode = child.ref.current\n        if (domNode) {\n            boundingBoxes[child.key] = domNode.getBoundingClientRect()\n        }\n    })\n\n    return boundingBoxes\n}\n\nexport default calculateBoundingBoxes\n","import React, { useEffect, useLayoutEffect, useState } from 'react'\nimport usePrevious from '../hooks/usePrevious'\nimport calculateBoundingBoxes from '../services/calculateBoundingBoxes'\nimport { DOMRectsObject } from '../types'\n\ninterface AnimateWordsProps {\n    ({ children }: { children: any }): React.ReactElement\n}\n\nconst AnimateWords: AnimateWordsProps = ({ children }) => {\n    const [boundingBox, setBoundingBox] = useState<DOMRectsObject>({})\n    const [prevBoundingBox, setPrevBoundingBox] = useState<DOMRectsObject>({})\n    const prevChildren = usePrevious(children)\n\n    useLayoutEffect(() => {\n        setBoundingBox(calculateBoundingBoxes(children))\n    }, [children])\n\n    useLayoutEffect(() => {\n        if (prevChildren) {\n            setPrevBoundingBox(calculateBoundingBoxes(prevChildren))\n        }\n    }, [prevChildren])\n\n    useEffect(() => {\n        const hasPrevBoundingBox = Object.keys(prevBoundingBox).length\n\n        React.Children.map(children, (child) => {\n            if (hasPrevBoundingBox) {\n                const domNode: HTMLDivElement | null = child.ref.current\n                const firstBox = prevBoundingBox[child.key]\n                const lastBox = boundingBox[child.key]\n\n                if (firstBox && lastBox) {\n                    const changeInX = firstBox.left - lastBox.left\n                    const changeInY = firstBox.bottom - lastBox.bottom\n\n                    if (changeInX !== 0 || changeInY !== 0) {\n                        requestAnimationFrame(() => {\n                            if (domNode) {\n                                domNode.style.transform = `translate(${changeInX}px, ${changeInY}px)`\n                                domNode.style.transition = 'transform 0s'\n\n                                requestAnimationFrame(() => {\n                                    domNode.style.transform = ''\n                                    domNode.style.transition = 'transform 500ms'\n                                })\n                            }\n                        })\n                    }\n                }\n            }\n        })\n    }, [boundingBox, prevBoundingBox, children])\n    return children\n}\n\nexport default AnimateWords\n","import React, { createRef, useCallback } from 'react'\nimport { DndProvider } from 'react-dnd'\nimport { HTML5Backend } from 'react-dnd-html5-backend'\nimport { TouchBackend } from 'react-dnd-touch-backend'\nimport { observer } from 'mobx-react-lite'\nimport Word from '../molecules/Word'\nimport Cloud from '../molecules/Cloud'\nimport CheckSentenceControls from '../molecules/CheckSentenceControls'\nimport AnimateWords from '../../hoc/AnimateWords'\nimport { isTouchDevice } from '../../services/isTouchDevice'\nimport { store } from '../../stores/store'\nimport { ItemT } from '../../types'\n\nconst DragAndDrop: React.FC = () => {\n    const isTouchScreen = isTouchDevice() ? TouchBackend : HTML5Backend\n    const renderWord = useCallback((word: ItemT, index: number, group?: 'start' | 'target') => {\n        return (\n            <Word\n                key={word.id + word.text}\n                id={word.id}\n                text={word.text}\n                index={index}\n                group={group}\n                ref={createRef<HTMLDivElement>()}\n            />\n        )\n    }, [])\n\n    return (\n        <>\n            <DndProvider backend={isTouchScreen}>\n                <Cloud group={'target'}>\n                    {store.targetWords?.map((word: ItemT, index: number) => renderWord(word, index, 'target'))}\n                </Cloud>\n                <Cloud group={'start'}>\n                    <AnimateWords>\n                        {store.startWords?.map((word: ItemT, index: number) => renderWord(word, index, 'start'))}\n                    </AnimateWords>\n                </Cloud>\n            </DndProvider>\n            <CheckSentenceControls />\n        </>\n    )\n}\n\nexport default observer(DragAndDrop)\n","export const isTouchDevice = () => {\r\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0;\r\n}\r\n","// extracted by mini-css-extract-plugin\nexport default {};","// extracted by mini-css-extract-plugin\nexport default {};","// extracted by mini-css-extract-plugin\nexport default {};","// extracted by mini-css-extract-plugin\nexport default {};"],"names":["WordContainer","props","isDragging","forwardRef","ref","refs","id","text","index","group","localRef","useRef","moveWord","useCallback","dragIndex","hoverIndex","store","update","$splice","useDrop","accept","collect","monitor","handlerId","getHandlerId","hover","item","current","hoverBoundingRect","getBoundingClientRect","hoverMiddleX","right","left","hoverClientX","getClientOffset","x","drop","useDrag","type","drag","value","forEach","Text","sortById","wordA","wordB","CloudContainer","children","moveWordToTargetGroup","$push","moveWordToStartGroup","setTimeout","sort","PrimaryButton","onClick","CheckSentenceControlsContainer","ButtonContainer","showStatus","VerificationStatusContainer","isCorrect","observer","useState","setCorrect","setShowStatus","utterThis","SpeechSynthesisUtterance","lang","speechSynthesis","speaking","speak","useEffect","boundingBoxes","React","child","domNode","key","boundingBox","setBoundingBox","prevBoundingBox","setPrevBoundingBox","prevChildren","usePrevious","useLayoutEffect","calculateBoundingBoxes","hasPrevBoundingBox","Object","keys","length","firstBox","lastBox","changeInX","changeInY","bottom","requestAnimationFrame","style","transform","transition","isTouchScreen","window","navigator","maxTouchPoints","TouchBackend","HTML5Backend","renderWord","word","createRef","DndProvider","backend","map"],"sourceRoot":""}
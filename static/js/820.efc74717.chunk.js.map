{"version":3,"file":"static/js/820.efc74717.chunk.js","mappings":"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","sources":["components/molecules/Word.tsx","utils/mergeRefs.ts","components/molecules/Group.tsx","components/atoms/Button.tsx","components/molecules/CheckSentenceControls.tsx","hooks/usePrevious.ts","utils/calculateBoundingBoxes.tsx","components/AnimateWords.tsx","components/organisms/DragDrop.tsx","utils/isTouchDevice.ts","webpack://my-app/./src/components/atoms/Button.tsx?f41e","webpack://my-app/./src/components/molecules/CheckSentenceControls.tsx?35c4","webpack://my-app/./src/components/molecules/Group.tsx?2eb5","webpack://my-app/./src/components/molecules/Word.tsx?fff4"],"sourcesContent":["import React, { forwardRef, useCallback, useRef } from 'react'\nimport { styled } from 'linaria/react'\nimport { useDrag, useDrop } from 'react-dnd'\nimport Text from '../atoms/Text'\nimport update from 'immutability-helper'\nimport mergeRefs from '../../utils/mergeRefs'\nimport { store } from '../../stores/store'\nimport type { Identifier, XYCoord } from 'dnd-core'\nimport { DragItem, ItemT } from '../../types'\n\ntype StyleProps = {\n    isDragging: boolean\n}\n\nconst WordContainer = styled.div<StyleProps>`\n    background: #fff;\n    border: 1px solid #949494;\n    border-radius: 12px;\n    cursor: grab;\n    margin: 5px;\n    user-select: none;\n\n    opacity: ${(props) => (props.isDragging ? 0.5 : 1)};\n`\n\ninterface WordProps {\n    id: number\n    text: string\n    index: number\n    group?: 'start' | 'target'\n}\n\nconst Word = forwardRef<HTMLDivElement, WordProps>(function Word({ id, text, index, group }, ref) {\n    const localRef = useRef<HTMLDivElement>(null)\n\n    const moveWord = useCallback((dragIndex: number, hoverIndex: number) => {\n        store.setTargetWords(\n            update(store.targetWords, {\n                $splice: [\n                    [dragIndex, 1],\n                    [hoverIndex, 0, store.targetWords[dragIndex] as ItemT],\n                ],\n            })\n        )\n    }, [])\n\n    const [{ handlerId }, drop] = useDrop<DragItem, void, { handlerId: Identifier | null }>({\n        accept: 'word',\n        collect: (monitor) => {\n            return {\n                handlerId: monitor.getHandlerId(),\n            }\n        },\n        hover: (item: DragItem, monitor) => {\n            if (group === 'target' && item.group === 'target') {\n                if (!localRef.current) {\n                    return\n                }\n                const dragIndex = item.index\n                const hoverIndex = index\n\n                if (dragIndex === hoverIndex) {\n                    return\n                }\n\n                const hoverBoundingRect = localRef.current?.getBoundingClientRect()\n                const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2\n                const clientOffset = monitor.getClientOffset()\n                const hoverClientX = (clientOffset as XYCoord).x - hoverBoundingRect.left\n\n                if (dragIndex < hoverIndex && hoverClientX < hoverMiddleX) {\n                    return\n                }\n\n                if (dragIndex > hoverIndex && hoverClientX > hoverMiddleX) {\n                    return\n                }\n\n                moveWord(dragIndex, hoverIndex)\n                item.index = hoverIndex\n            }\n        },\n    })\n\n    const [{ isDragging }, drag] = useDrag({\n        type: 'word',\n        item: () => {\n            return { id, index, group }\n        },\n        collect: (monitor) => ({\n            isDragging: monitor.isDragging(),\n        }),\n    })\n    drag(drop(localRef))\n    return (\n        <WordContainer ref={mergeRefs([localRef, ref])} isDragging={isDragging} data-handler-id={handlerId}>\n            <Text text={text} />\n        </WordContainer>\n    )\n})\n\nexport default Word\n","import React from 'react'\r\n\r\nexport default function mergeRefs<T = never>(\r\n    refs: Array<React.MutableRefObject<T> | React.LegacyRef<T>>\r\n): React.RefCallback<T> {\r\n    return (value) => {\r\n        refs.forEach((ref) => {\r\n            if (typeof ref === 'function') {\r\n                ref(value)\r\n            } else if (ref != null) {\r\n                ;(ref as React.MutableRefObject<T | null>).current = value\r\n            }\r\n        })\r\n    }\r\n}\r\n","import React, { useCallback } from 'react'\nimport { styled } from 'linaria/react'\nimport { useDrop } from 'react-dnd'\nimport update from 'immutability-helper'\nimport { store } from '../../stores/store'\nimport { DragItem } from '../../types'\n\ninterface CloudProps {\n    type: 'start' | 'target'\n}\n\nconst GroupContainer = styled.div`\n    align-content: flex-start;\n    border-top: 1px solid #030303;\n    display: flex;\n    flex-wrap: wrap;\n    min-height: 110px;\n    padding: 6px;\n`\n\nconst Group: React.FC<CloudProps> = ({ type, children }) => {\n    const moveWordToTargetGroup = useCallback((dragIndex: number) => {\n        store.setTargetWords(\n            update(store.targetWords, {\n                $push: [store.startWords[dragIndex]],\n            })\n        )\n        store.setStartWords(\n            update(store.startWords, {\n                $splice: [[dragIndex, 1]],\n            })\n        )\n    }, [])\n\n    const moveWordToStartGroup = useCallback((dragIndex: number) => {\n        store.setStartWords(\n            update(store.startWords, {\n                $push: [store.targetWords[dragIndex]],\n            })\n        )\n        store.setTargetWords(\n            update(store.targetWords, {\n                $splice: [[dragIndex, 1]],\n            })\n        )\n    }, [])\n\n    const [, drop] = useDrop<DragItem, void>({\n        accept: 'word',\n        drop: (item) => {\n            const dragIndex = item.index\n            if (type === 'target' && item.group === 'start') {\n                moveWordToTargetGroup(dragIndex)\n            }\n            if (type === 'start' && item.group === 'target') {\n                moveWordToStartGroup(dragIndex)\n                setTimeout(() => store.sortStartWords(), 500)\n            }\n        },\n    })\n    return <GroupContainer ref={drop}>{children}</GroupContainer>\n}\n\nexport default Group\n","import React from 'react'\r\nimport { styled } from 'linaria/react'\r\n\r\ninterface ButtonProps {\r\n    onClick: () => void\r\n}\r\n\r\nconst PrimaryButton = styled.button`\r\n    background: #fff;\r\n    border: 1px solid #fff;\r\n    border-radius: 30px;\r\n    box-shadow: 5px 7px 10px rgba(0, 0, 0, 0.1);\r\n    font-size: medium;\r\n    font-weight: 600;\r\n    padding: 16px 0;\r\n    width: 100%;\r\n\r\n    &:active {\r\n        box-shadow: -5px -8px 10px rgba(0, 0, 0, 0.1);\r\n    }\r\n`\r\n\r\nconst Button: React.FC<ButtonProps> = ({ onClick }) => {\r\n    return <PrimaryButton onClick={onClick}>Check</PrimaryButton>\r\n}\r\n\r\nexport default Button\r\n","import React, { useState } from 'react'\r\nimport { styled } from 'linaria/react'\r\nimport { observer } from 'mobx-react-lite'\r\nimport Text from '../atoms/Text'\r\nimport Button from '../atoms/Button'\r\nimport { store } from '../../stores/store'\r\n\r\ntype StyleProps = {\r\n    showStatus: boolean\r\n    isCorrect: boolean\r\n}\r\n\r\nconst CheckSentenceControlsContainer = styled.div`\r\n    height: 120px;\r\n    margin-top: 16px;\r\n`\r\n\r\nconst ButtonContainer = styled.div<Pick<StyleProps, 'showStatus'>>`\r\n    margin: -40px auto 0;\r\n    transform: translate3d(0, ${props => props.showStatus ? '50px' : '0'}, 0);\r\n    transition: transform 500ms ease;\r\n    width: 90%;\r\n`\r\n\r\nconst VerificationStatusContainer = styled.div<Pick<StyleProps, 'isCorrect'>>`\r\n    display: flex;\r\n    color: transparent;\r\n    font-weight: 600;\r\n    justify-content: center;\r\n\r\n    p {\r\n        color: ${(props) => (props.isCorrect ? '#17d217' : '#f31616')};\r\n    }\r\n`\r\n\r\nconst CheckSentenceControls: React.FC = () => {\r\n    const [isCorrect, setCorrect] = useState<boolean>(false)\r\n    const [showStatus, setShowStatus] = useState<boolean>(false)\r\n\r\n    const checkSentence = () => {\r\n        store.setSentenceToCheck()\r\n        if (store.sentenceToCheck !== store.currentSentence.en) {\r\n            setCorrect(false)\r\n        }\r\n        if (store.sentenceToCheck === store.currentSentence.en) {\r\n            const utterThis = new SpeechSynthesisUtterance(store.sentenceToCheck)\r\n            utterThis.lang = 'en-US'\r\n            setCorrect(true)\r\n            setTimeout(() => store.renderNewSentence(), 3000)\r\n            if (!speechSynthesis.speaking) {\r\n                speechSynthesis.speak(utterThis)\r\n            }\r\n        }\r\n        setShowStatus(true)\r\n        setTimeout(() => setShowStatus(false), 1500)\r\n    }\r\n\r\n    return (\r\n        <CheckSentenceControlsContainer>\r\n            <VerificationStatusContainer isCorrect={isCorrect}>\r\n                {isCorrect ? <Text text={'Correct!'} /> : <Text text={'Something is wrong!'} />}\r\n            </VerificationStatusContainer>\r\n            <ButtonContainer showStatus={showStatus}>\r\n                <Button onClick={checkSentence} />\r\n            </ButtonContainer>\r\n        </CheckSentenceControlsContainer>\r\n    )\r\n}\r\n\r\nexport default observer(CheckSentenceControls)\r\n","import { MutableRefObject, useEffect, useRef } from 'react'\r\n\r\nfunction usePrevious<T>(value: T): MutableRefObject<T | undefined>['current'] {\r\n    const ref = useRef<T>()\r\n    useEffect(() => {\r\n        ref.current = value\r\n    }, [value])\r\n    return ref.current\r\n}\r\n\r\nexport default usePrevious\r\n","import React from 'react'\r\nimport { DOMRectsObject } from '../types'\r\nimport { AnimateWordsChild } from '../types'\r\n\r\nconst calculateBoundingBoxes = (children: AnimateWordsChild[] ) => {\r\n    const boundingBoxes: DOMRectsObject = {}\r\n    React.Children.map(children, (child) => {\r\n        const domNode: HTMLDivElement | null | undefined = child.ref?.current\r\n        if (domNode && child.key) {\r\n            boundingBoxes[child.key] = domNode.getBoundingClientRect()\r\n        }\r\n    })\r\n\r\n    return boundingBoxes\r\n}\r\n\r\nexport default calculateBoundingBoxes\r\n","import React, { useEffect, useLayoutEffect, useState } from 'react'\nimport usePrevious from '../hooks/usePrevious'\nimport calculateBoundingBoxes from '../utils/calculateBoundingBoxes'\nimport { AnimateWordsChild, DOMRectsObject } from '../types'\n\ninterface AnimateWordsProps {\n    children: AnimateWordsChild[]\n}\n\nconst AnimateWords: React.FC<AnimateWordsProps> = ({ children }) => {\n    const prevChildren = usePrevious(children)\n    const [boundingBox, setBoundingBox] = useState<DOMRectsObject>({})\n    const [prevBoundingBox, setPrevBoundingBox] = useState<DOMRectsObject>({})\n\n    useLayoutEffect(() => {\n        setBoundingBox(calculateBoundingBoxes(children))\n    }, [children])\n\n    useLayoutEffect(() => {\n        if (prevChildren) {\n            setPrevBoundingBox(calculateBoundingBoxes(prevChildren))\n        }\n    }, [prevChildren])\n\n    useEffect(() => {\n        const hasPrevBoundingBox = Object.keys(prevBoundingBox).length\n\n        React.Children.map(children, (child: AnimateWordsChild) => {\n            if (hasPrevBoundingBox && child.key) {\n                const domNode: HTMLDivElement | null | undefined = child.ref?.current\n                const firstBox = prevBoundingBox[child.key]\n                const lastBox = boundingBox[child.key]\n\n                if (firstBox && lastBox) {\n                    const changeInX = firstBox.left - lastBox.left\n                    const changeInY = firstBox.bottom - lastBox.bottom\n\n                    if (changeInX !== 0 || changeInY !== 0) {\n                        requestAnimationFrame(() => {\n                            if (domNode) {\n                                domNode.style.transform = `translate3d(${changeInX}px, ${changeInY}px, 0)`\n                                domNode.style.transition = 'transform 0ms'\n\n                                requestAnimationFrame(() => {\n                                    domNode.style.transform = 'translate3d(0, 0, 0)'\n                                    domNode.style.transition = 'transform 250ms'\n                                })\n                            }\n                        })\n                    }\n                }\n            }\n        })\n    }, [boundingBox, prevBoundingBox, children])\n    return <>{children}</>\n}\n\nexport default AnimateWords\n","import React, { createRef, useCallback } from 'react'\nimport { DndProvider } from 'react-dnd'\nimport { HTML5Backend } from 'react-dnd-html5-backend'\nimport { TouchBackend } from 'react-dnd-touch-backend'\nimport { observer } from 'mobx-react-lite'\nimport Word from '../molecules/Word'\nimport Group from '../molecules/Group'\nimport CheckSentenceControls from '../molecules/CheckSentenceControls'\nimport AnimateWords from '../AnimateWords'\nimport { isTouchDevice } from '../../utils/isTouchDevice'\nimport { store } from '../../stores/store'\nimport { ItemT } from '../../types'\n\nconst DragAndDrop: React.FC = () => {\n    const isTouchScreen = isTouchDevice() ? TouchBackend : HTML5Backend\n    const renderWord = useCallback((word: ItemT, index: number, group?: 'start' | 'target') => {\n        return (\n            <Word\n                key={word.id + word.text}\n                id={word.id}\n                text={word.text}\n                index={index}\n                group={group}\n                ref={createRef<HTMLDivElement>()}\n            />\n        )\n    }, [])\n\n    return (\n        <>\n            <DndProvider backend={isTouchScreen}>\n                <Group type={'target'}>\n                    {store.targetWords?.map((word: ItemT, index: number) => renderWord(word, index, 'target'))}\n                </Group>\n                <Group type={'start'}>\n                    <AnimateWords>\n                        {store.startWords?.map((word, index) => (\n                            <Word\n                                key={word.id + word.text}\n                                id={word.id}\n                                text={word.text}\n                                index={index}\n                                group={'start'}\n                            />\n                        ))}\n                    </AnimateWords>\n                </Group>\n            </DndProvider>\n            <CheckSentenceControls />\n        </>\n    )\n}\n\nexport default observer(DragAndDrop)\n","export const isTouchDevice = () => {\r\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0;\r\n}\r\n","// extracted by mini-css-extract-plugin\nexport default {};","// extracted by mini-css-extract-plugin\nexport default {};","// extracted by mini-css-extract-plugin\nexport default {};","// extracted by mini-css-extract-plugin\nexport default {};"],"names":["WordContainer","props","isDragging","forwardRef","ref","refs","id","text","index","group","localRef","useRef","moveWord","useCallback","dragIndex","hoverIndex","store","update","$splice","useDrop","accept","collect","monitor","handlerId","getHandlerId","hover","item","current","hoverBoundingRect","getBoundingClientRect","hoverMiddleX","right","left","hoverClientX","getClientOffset","x","drop","useDrag","type","drag","value","forEach","Text","GroupContainer","children","moveWordToTargetGroup","$push","moveWordToStartGroup","setTimeout","PrimaryButton","onClick","CheckSentenceControlsContainer","ButtonContainer","showStatus","VerificationStatusContainer","isCorrect","observer","useState","setCorrect","setShowStatus","utterThis","SpeechSynthesisUtterance","lang","speechSynthesis","speaking","speak","useEffect","boundingBoxes","React","child","domNode","key","prevChildren","usePrevious","boundingBox","setBoundingBox","prevBoundingBox","setPrevBoundingBox","useLayoutEffect","calculateBoundingBoxes","hasPrevBoundingBox","Object","keys","length","firstBox","lastBox","changeInX","changeInY","bottom","requestAnimationFrame","style","transform","transition","isTouchScreen","window","navigator","maxTouchPoints","TouchBackend","HTML5Backend","renderWord","word","createRef","DndProvider","backend","map"],"sourceRoot":""}